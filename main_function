library(remotes)
library(sampling)
library(survey)
library(nonprobsvy)
library(ggplot2)
library(pps)
library(compositions)
library(robustbase)
# library(cem)
library(MatchIt)
# library(tidyverse)
library(dummies)
library(MASS)

library(plyr)
library(KWML)
library(lme4)
library(depmixS4)
library(snowfall)
library(pROC)


#批注
#group这个变量应该是函数自动生成比较好
#三个方法到时候要改一下名字
#做软件的时候，需要对每个待输入的参数进行质控：变量类型、能否是空值等
#现在的function先算个点估计值，后续如果要做软件就再把bootstrap那套程序放上去
# sweight是用于合并样本建模时候的权重，并不是概率样本的抽样权重  


##############################################################################################
###########################################计算核平滑值
##############################################################################################
K <- function(x) {(1 / sqrt(2 * pi)) * exp(-x^2 / 2)}

##############################################################################################
###########################################计算TL方差
##############################################################################################
#############################################################################
# FUNCTION v2_fun is a function to calculate complete TL variance for a     #
#          pseudo-weighted estimate of finite population mean. No clustering#
#          or stratification is considered for either cohort or survey      #
# INPUT                                                                     #
#  pw:        pseudo-weight                                                 #
#  pw_beta:   partial derivative of pw w.r.t propensity model coefficients  #
#  mu_hat:    estimate of finite population mean                            #
#  model.par: a list including estimated PS and design matrix for cohort and#
#             survey sample                                                 #
#  y:         variable of interest                                          #
#  svy.wt:    vector of survey sample weights                               #
# OUTPUT                                                                    #
#  v_all: variance matrix of the propensity model coefficients and mu       #
#############################################################################
v2_fun = function(pw, pw_beta, mu_hat, model.par, y, svy.wt){
  # Propensity score for cohort and survey sample
  p.c = model.par$p.c; p.s = model.par$p.s 
  # design matrix for cohort and survey sample
  design.x.c = model.par$design.x.c; design.x.s = model.par$design.x.s
  # sample size for cohort and survey sample
  n_c = length(p.c); n_s = length(p.s)
  # Take derivative of Phi w.r.t mu and beta (phi), and phi inverse
  U_mu   = -sum(pw); U_beta = c(y-mu_hat)%*%pw_beta
  S_mu   = rep(0, dim(pw_beta)[2])
  S_beta = -t(p.c*(1-p.c)*design.x.c)%*%design.x.c-
    t(svy.wt* p.s*(1-p.s)*design.x.s)%*%design.x.s
  S_beta_inv = solve(S_beta); b=-1/U_mu*U_beta%*%S_beta_inv
  phi_inv = rbind(c(1/U_mu, b), cbind(S_mu, S_beta_inv))
  # Calculate var(Phi)
  Phi_1  = as.data.frame(cbind(pw*(y-mu_hat), (1-p.c)*design.x.c))
  Phi_2  = -as.data.frame(cbind(0, svy.wt* p.s*design.x.s))
  v1 = var(Phi_1)*n_c; v2 = var(Phi_2)*n_s; v_Phi = v1+v2    ###这两处应该是除以样本量的平方才对
  v_all = phi_inv%*%v_Phi%*%t(phi_inv)
  return(list(v_all=v_all))
} # End FUNCTION v2_fun

##############################################################################################
###########################################主函数
##############################################################################################
#######################################################################################
# 参数说明                                                                            #
# data_NP:非概率样本                                                                  #
# data_P:参考样本（概率样本）                                                         #
# CIV:非概率样本与参考样本共同的变量名                                                #
# type_CIV:非概率样本与参考样本共同变量的类型,可选'guassian','binomial','multinomial' #
# DV_NP:结局变量名                                                                    #
# DV_type:结局变量的类型，可选'guassian','binomial'                                   #
# sample_w:概率样本的抽样权重                                                         #
# maxclassnum:潜分类数目最大值                                                        #
#######################################################################################
NPinfer_ALC <-
  function(data_NP=data_A,data_P=data_B,
           CIV=c('X1','X2','X3','X4','X5'),type_CIV=c('binomial','gaussian','gaussian','gaussian','gaussian'),
           DV_NP='Y',DV_type='gaussian',sample_weight='sample_weight',
           maxclassnum=5)
  {
    #################################################################################################
    ##################################################################################数据预处理-----
    #################################################################################################
    
    #计算校正因子
    a <- 1-nrow(data_P)/sum(data_P[,sample_weight])
    
    #计算参考样本校正后的抽样权重
    SW_P <- data_P[,sample_weight]*a
    OSW_P <- data_P[,sample_weight]
    data_P <- cbind(data_P,SW=SW_P,OSW=OSW_P)
    
    #定义非概率样本的两个权重变量
    SW_NP <- rep(1,times=nrow(data_NP))
    OSW_NP <- rep(1,times=nrow(data_NP))
    data_NP <- cbind(data_NP,SW=SW_NP,OSW=OSW_NP)

    #生成表示id的变量
    id <- 1:length(nrow(data_NP)+nrow(data_P))
    #合并两个样本以及id列,生成表示样本来源的字符型变量datatype和数值型变量group(1-NP;0-P)
    data_com <- cbind(rbind.fill(cbind(data_NP,group=1),cbind(data_P,group=0)),id)
    
    #################################################################################################
    ################################################################识别潜分类-------
    #################################################################################################
    data_com1 <- data_com
    for (CIV_i in 1:length(CIV)) {
      if(type_CIV[CIV_i]=='binomial'){ data_com1[,CIV[CIV_i]] <- as.numeric(factor(data_com1[,CIV[CIV_i]]))-1 }
      
      if(type_CIV[CIV_i]=='multinomial'){ data_com1[,CIV[CIV_i]] <- as.numeric(factor(data_com1[,CIV[CIV_i]])) }

      if(type_CIV[CIV_i]=='gaussian'){ data_com1[,CIV[CIV_i]] <- data_com1[,CIV[CIV_i]] }
    }
    
    #用于潜分类分析的表达式
    expr_variable <- paste('list(',paste(paste(CIV,'~1',sep=''),collapse = ','),')',sep='')
    expr_type <- paste('list(',paste(paste(type_CIV,'()',sep=''),collapse = ','),')',sep='')
    
    #识别潜分类：BIC向量是用于存储每个潜分类下的BIC值
    BIC <- NULL;results_FM <- NULL
    for (i_class in 1:maxclassnum) {
      lca <- depmixS4::mix(eval(str2lang(expr_variable)),
                           data=data_com1,
                           nstates = i_class,
                           family = eval(str2lang(expr_type)))
      Ind_lca1 <- try(fit <- fit(lca),silent=TRUE)
      
      #防止上面的模型跑不出来，设置一个while循环让它可以跑出来为止
      T <- 0
      while(methods::is(Ind_lca1,"try-error")==TRUE & T<=10) {
        lca <- depmixS4::mix(eval(str2lang(expr_variable)),
                             data=data_com1,
                             nstates = i_class,
                             family = eval(str2lang(expr_type)))
        Ind_lca1 <- try(fit <- fit(lca),silent=TRUE)
        T <- T+1
      }
      if(methods::is(Ind_lca1,"try-error")==TRUE){stop('The finite mixture model cannot be fitted')}
      
      BIC[i_class] <- BIC(fit)
      results_FM <- cbind(results_FM,fit@posterior$state)
    }
    bestnum_vec <- which(BIC==min(BIC))
    if(length(bestnum_vec)>=1){bestnum <- bestnum_vec[1]}
    if(length(bestnum_vec)==1){bestnum <- bestnum_vec}
    LC <- results_FM[,bestnum]
    
    #################################################################################################
    ################################################################根据所识别潜分类建立模型-------
    #################################################################################################
    
    #把多分类转变为哑变量
    data_com2 <- cbind(data_com,LC)
    CIV_2 <- NULL
    
    for (CIV_i in 1:length(CIV)){
      
      if(type_CIV[CIV_i]=='binomial'){ 
        data_com2[,CIV[CIV_i]] <- as.numeric(factor(data_com2[,CIV[CIV_i]]))-1 
        CIV_2 <- c(CIV_2,CIV[CIV_i])
      }
      
      if(type_CIV[CIV_i]=='multinomial'){ 
        dummy_var <- model.matrix(~ data_com2[,CIV[CIV_i]] - 1, data = data_com2)
        dummy_num <- length(unique(data_com2[,CIV[CIV_i]]))
        dummy_name <- paste(CIV[CIV_i],1:dummy_num,sep='')
        colnames(dummy_var) <- dummy_name
        dummy_var2 <- dummy_var[,-1]
        data_com2 <- cbind(data_com2,dummy_var)
        dummy_name2 <- colnames(dummy_var2)
        CIV_2 <- c(CIV_2,dummy_name2)
      }
      
      if(type_CIV[CIV_i]=='gaussian'){ 
        data_com2[,CIV[CIV_i]] <- data_com2[,CIV[CIV_i]] 
        CIV_2 <- c(CIV_2,CIV[CIV_i])
      }
      
    }
    
    #当最佳潜分类是1时，就没必要扣除潜在的异质性了，直接用普通回归
    if(bestnum==1){
      #生成新的非概率样本和参考样本
      data_NP2 <- data_com2[data_com2$group==1,]
      data_P2 <- data_com2[data_com2$group==0,]
      
      #逆概率加权的模型表达式及模型构建
      formula_myipw <- paste('group~',paste(CIV_2,collapse = '+'),sep='')
      fit_toNP <- glm(eval(str2lang(formula_myipw)), data=data_com2, family='binomial', weights = SW)
      
      #超总体的模型表达式及模型构建
      formula_mysp <- paste(DV_NP,'~',paste(CIV_2,collapse = '+'),sep='')
      fit_Y <- glm(eval(str2lang(formula_mysp)), data=data_NP2,family=DV_type)
    }#bestnum==1
    
    #如果最佳潜分类超过1，使用多水平模型考虑异质性，最后生成fit_toNP和fit_Y用于后续计算
    if(bestnum!=1){
      #把潜分类模型的分类结果添加到数据集上，并分别生成新的非概率样本和参考样本
      data_NP2 <- data_com2[data_com2$group==1,]
      data_P2 <- data_com2[data_com2$group==0,]
      
      #逆概率加权的模型表达式
      formula_myipw <- paste('group~(',paste(CIV_2,collapse = '+'),'|LC)',sep='')
      suppressWarnings(fit_toNP <- glmer(eval(str2lang(formula_myipw)), data=data_com2, family=binomial, weights = SW))
      
      #超总体的模型表达式及模型构建
      formula_mysp <- paste(DV_NP,'~(',paste(CIV_2,collapse = '+'),'|LC)',sep='')
      suppressWarnings(fit_Y <- glmer(eval(str2lang(formula_mysp)), data=data_NP2,family=DV_type))
    }#bestnum!=1
    
    #################################################################################################
    ################################################################改进逆概率加权法下的点估计值------
    #################################################################################################
    
    #先计算合并样本中每个个体的入样倾向性评分
    ps_BOTH <- predict(fit_toNP, newdata=data_com2, type="link")
    #单独提取非概率样本的倾向性评分
    ps_NP <- ps_BOTH[data_com2$group==1]
    #单独提取参考样本的倾向性评分
    ps_P <- ps_BOTH[data_com2$group==0]
    #参考样本的抽样权重(经过加权校正)
    sweight_P <- data_com2[data_com2$group==0,'SW']
    #计算非概率样本核平滑后的权重
    fit_kernal <- kw.wt(p_score.c = ps_NP,p_score.s = ps_P,svy.wt = sweight_P,krn = "dnorm")                #核函数：标准正态分布
    kwweight_NP <- fit_kernal$pswt
    point_kwipw <- sum(data_NP2[,DV_NP]*kwweight_NP)/sum(kwweight_NP)
    h <- fit_kernal$h
    
    #####################################################################################TL方差：借鉴作者的代码
    #两个样本的入样概率预测值
    PP_P <- predict(fit_toNP, newdata=data_P2, type="response")
    PP_NP <- predict(fit_toNP, newdata=data_NP2, type="response")
    #定义两个样本的自变量矩阵
    design_matrix_NP <- data_com2[data_com2$group==1,CIV_2]
    design_matrix_P <- data_com2[data_com2$group==0,CIV_2]
    #共同变量的数目；非概率样本的样本量
    n_CIV <- ncol(design_matrix_NP);n_NP <- nrow(design_matrix_NP)
    #计算概率样本(行)与非概率样本(列)自变量的距离矩阵
    sgn_dist_mtx <- outer(ps_P,ps_NP,FUN = '-')
    #对距离矩阵进一步核转换
    krn_num <- K(sgn_dist_mtx/h)
    #核转换距离矩阵的
    row.krn = rowSums(krn_num) # sum_i\in s_c [K[{p^(s)_j- p^(s)_j}/h]]
    #计算w关于beta的偏导
    pw_beta=matrix(0, n_NP, n_CIV)
    for(i in 1:n_CIV){
      design.x.dist=outer(design_matrix_P[,i], design_matrix_NP[,i], FUN="-")
      kij_beta = -krn_num*sgn_dist_mtx*design.x.dist/h^2  
      row.kij_beta = rowSums(kij_beta)                    
      deriv1= (sweight_P/row.krn)%*%kij_beta
      deriv2= -(sweight_P*row.kij_beta/row.krn/row.krn)%*%krn_num
      pw_beta[,i] = deriv1+deriv2}
    #定义参数，包括两个样本的倾向性评分和设计矩阵
    model.par <- list(p.c=PP_NP,p.s=PP_P,design.x.c=as.matrix(design_matrix_NP),design.x.s=as.matrix(design_matrix_P))
    #计算均数和回归系数的方差
    V_kwipw <- v2_fun(pw=kwweight_NP, pw_beta=pw_beta, mu_hat=point_kwipw, model.par=model.par, y=data_NP2[,DV_NP], svy.wt=sweight_P)$v_all[1,1]
    #计算置信区间
    CI_kwipw <- data.frame('lower_bound'=point_kwipw-1.96*sqrt(V_kwipw),'upper_bound'=point_kwipw+1.96*sqrt(V_kwipw))
    
    #################################################################################################
    ################################################################改进超总体模型下的结局点估计值------
    #################################################################################################
    
    #计算参考样本的结局预测值
    if(DV_type=='gaussian'){PDV_P <- predict(fit_Y, newdata=data_P2)}
    if(DV_type=='binomial'){
      #基于非概率样本通过Youden指数计算最优的分类阈值
      # linear_PDV_NP <- predict(fit_Y, newdata=data_NP2,type='response')
      # roc_NP <- roc(data_NP2[,DV_NP],linear_PDV_NP)
      # cutoff_NP <- coords(roc_NP,'best',ret=c('threshold'),best.method=c("youden"))
      
      # linear_PDV_P <- predict(fit_Y, newdata=data_P2,type='response')
      # PDV_P <- ifelse(linear_PDV_P>=cutoff_NP$threshold, 1, 0)
      
      PDV_P <- predict(fit_Y, newdata=data_P2,type='response')
      
    }
    #通过设定设计类型来计算
    sweight2_P <- data_P2[,'OSW']
    PDV_svydesign <- svydesign(ids=~1, weights=sweight2_P,  data=data.frame(sweight2_P,PDV_P))
    out_PDV <- svymean(~PDV_P,PDV_svydesign)
    #点估计值
    point_newsp <- out_PDV[[1]]

    #计算方差
    V_newsp <- attr(out_PDV,"var")[1]

    #计算置信区间
    CI_newsp <- data.frame('lower_bound'=point_newsp-1.96*sqrt(V_newsp),'upper_bound'=point_newsp+1.96*sqrt(V_newsp))
    
    #################################################################################################
    ################################################################改进双稳健估计法下的结局点估计值-----
    #################################################################################################
    
    #计算非概率样本的结局预测值
    if(DV_type=='gaussian'){PDV_NP <- predict(fit_Y, newdata=data_NP2)}
    if(DV_type=='binomial'){
      # PDV_NP <- ifelse(linear_PDV_NP>=cutoff_NP$threshold, 1, 0)
      
      PDV_NP <- predict(fit_Y, newdata=data_NP2,type='response')
      }
    #双稳健合并的点估计值
    point_kwdr <- (sum((data_NP2[,DV_NP]-PDV_NP)*kwweight_NP)/sum(kwweight_NP)) + point_newsp
    #残差向量
    redidual_P <- data_NP2[,DV_NP]-PDV_NP
    point_redidual_P <- (sum((data_NP2[,DV_NP]-PDV_NP)*kwweight_NP)/sum(kwweight_NP))
    #point_kwdr代替point_kwipw，redidual_P代替data_NP2[,DV_NP]；计算均数和回归系数的方差
    V_dr_1 <- v2_fun(pw=kwweight_NP, pw_beta=pw_beta, mu_hat=point_redidual_P, model.par=model.par, y=redidual_P, svy.wt=sweight_P)$v_all[1,1]
    #加和两部分的方差
    V_dr <- V_dr_1+V_newsp
    #计算置信区间
    CI_kwdr <- data.frame('lower_bound'=point_kwdr-1.96*sqrt(V_dr),'upper_bound'=point_kwdr+1.96*sqrt(V_dr))
    
    
    ################################################################将所计算的点估计值和方差输出
    output <- list('point_kwipw'=point_kwipw,
                   'point_newsp'=point_newsp,
                   'point_kwdr'=point_kwdr,
                   'CI_kwipw'=CI_kwipw,
                   'CI_newsp'=CI_newsp,
                   'CI_kwdr'=CI_kwdr)
    return(output)
    
  }#function:NPinfer_ALC
